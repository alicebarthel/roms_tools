***GENERATING INPUT FILES***

cice_grid.py: Given a ROMS grid file, create corresponding CICE grid and kmt
              (land mask) files.
	      To run: Open python or ipython, and type "run cice_grid.py." The
	              script will prompt you for paths to the existing ROMS
		      grid file and the desired CICE grid and kmt files.
woa_netcdf.py: Converts World Ocean Atlas temperature and salinity data from
               text file (FESOM input format) to NetCDF.
	       To run: First edit user parameters (file paths) near the top of
	               the file. Then open python/ipython and type "run
		       woa_netcdf.py".

romscice_ini_woa.py: Builds a ROMS initialisation file using World Ocean Atlas
                     data for temperature and salinity; starts with a motionless
		     ocean and zero sea surface height. Under ice shelves, sets
		     the salinity to a constant value (34.5 psu) and the
		     temperature to the local freezing point. Uses WOA data
		     assumed to be converted from FESOM input using
		     woa_netcdf.py
		     To run: First edit user parameters (file paths and grid
		             parameters) near the bottom of the file (after the
			     Then make sure that you have scipy version 0.14 or
			     higher (on raijin, this  means switching to
			     python/2.7.6; instructions at the top of the file).
			     Then open python/ipython and type "run
			     romscice_ini_woa.py".

romscice_nbc.py: Builds a ROMS northern lateral boundary condition file from 1
                 year of monthly ECCO2 data for temperature, salinity, and
		 velocity (set sea surface height to zero). Also contains useful
		 code for calculating volume averages.
		 To run: Edit user parameters near the top of the script
		         (mainly just file paths). Then make sure that you have
			 scipy version 0.14 or higher (on raijin, this means
			 switching to python/2.7.6; instructions at the top
			 of the file). Then open python or ipython and type
			 "run romscice_nbc.py".

romscice_atm_monthly.py: Convert ERA-Interim files of monthly averaged
                         atmospheric forcing to ROMS-CICE input forcing files
			 on the correct grid and with the correct units.
			 To run: Edit file paths near the top of the file and
			         start/end years near the bottom. Then open
				 python or ipython and type "run
				 romscice_atm_monthly.py".

romscice_nbc_rep.py: Given a ROMS lateral bounday condition file with one year
                     of monthly data, convert it to a file which can be used
		     repeatedly year after year (for eg spinup).
		     To run: Edit the user parameter (path to LBC file)
		             near the bottom of the file. Then open python or
			     ipython and type "run romscice_nbc_rep.py".

romscice_atm_rep.py: Given a ROMS atmospheric boundary condition file with one
                     year of monthly data, convert it to a file which can be
		     used repeatedly year after year (for eg spinup).
		     To run: Edit the paths to ERA-Interim files at the bottom
		             of the file. Then open python or ipython and type
			     "run romscice_atm_rep.py".

romscice_tides.py: Create a ROMS tide file containing the first 10 tidal
                   components interpolated from TPXO 7.2.
		   To run: Edit the paths to input and output files near the
		           top of the script. Then make sure that you have
			   scipy version 0.14 or higher (on raijin, this means
			   switching to python/2.7.6; instructions at the top
			   of the file). Then open python or ipython and type
			   "run romscice_tides.py".


***POST-PROCESSING DIAGNOSTICS***

plot_kinetic_energy.py: Extracts the kinetic energy values written in the
                        ocean.log files (you can supply as many ocean.log files
			as you like, from e.g. a long run split into several
			simulations) and plots the timeseries.
			To run: Open python or ipython, and type "run
			        plot_kinetic_energy.py". The script will prompt
				you for the paths to as many sequential
				ocean.log files as you like, as well as the
				timestep length and the output frequency for
				ocean.log (INFOSTEP in Params.py if you are
				using ROMS-CICE-MCT).

plot_maxspeed.py: Extracts the maximum velocity values written in the ocean.log
                  files (you can supply as many ocean.log files as you like,
		  from e.g. a long run split into several simulations) and plots
		  the timeseries.
		  To run: Open python or ipython, and type "run
		          plot_maxspeed.py". The script will prompt you for the
			  paths to as many sequential ocean.log files as you
			  like, as well as the timestep length and the output
			  frequency for ocean.log (INFOSTEP in Params.py if you
			  are using ROMS-CICE-MCT).

plot_volume.py: Extracts the volume values written in the ocean.log files (you
                can supply as many ocean.log files as you like, from e.g. a
		long run split into several simulations), converts them into
		percent anomalies (with respect to the initial value), and
		plots the timeseries.
		To run: Open python or ipython, and type "run plot_volume.py".
		        The script will prompt you for the paths to as many
			sequential ocean.log files as you like, as well as the
			timestep length and the output frequency for ocean.log
			(INFOSTEP in Params.py if you are using ROMS-CICE-MCT).

spinup_plots.py: Analyse a ROMS spinup by calculating and plotting 9 timeseries:
                 total heat content, total salt content, area-averaged ice shelf
		 melt rate, ice shelf basal mass loss, total kinetic energy,
		 Drake Passage transport, total sea ice extent, net sea ice-to-
		 ocean freshwater flux, and area-averaged bottom water
		 temperature in ice shelf cavities. Also write the timeseries to
		 a log file so they don't have to be recomputed if the run is
		 extended; at the beginning of this script, previous values will
		 be read from the same log file if it exists. Note that to run
		 this file, density anomalies (variable name "rho") must be
		 written to the ocean history/averages file. This option can be
		 activated in the .in ROMS configuration file with Hout(idDano)
		 and Aout(idDano). Otherwise, you can use make_density_file.py
		 to calculate absolute density based on the seawater equation of
		 state; however, this process is quite slow.
		 To run: First edit the i and j coordinates of the Drake Passage
		         (in the function calc_drakepsgtrans) for your grid, and
			 the value of rho0 (in the function get_rho) to match
			 what is in your .in ROMS configuration file. Then open
			 python or ipython, and type "run spinup_plots.py". The
			 script will prompt you for the paths to the ROMS grid
			 file, the ocean history or averages file, the CICE
			 history file (concatenate the (individual files first
			 so it contains the same timesteps as the ROMS
			 history/averages file), and the log file.

dpt_2d.py: Calculates zonal transport through each grid cell in the Drake
           Passage, vertically integrates, and makes a contour plot of 2D
	   (latitude vs time) result.
	   To run: Edit the i and j coordinates of the Drake Passage, near the
	           top of the file, for your grid. Then open python or ipython
		   and type "run dpt_2d.py". The script will prompt you for
		   paths to the ROMS grid file and the ocean history or averages
		   file.

dpt_2d_int.py: Like dpt_2d.py, but plots the indefinite integral over latitude
               (cumulative sum north to south) of transport.
	       To run: Edit the i and j coordinates of the Drake Passage, near
	               the top of the file, for your grid. Then open python or
		       ipython and type "run dpt_2d.py". The script will prompt
		       you for paths to the ROMS grid file and the ocean history
		       or averages file.

dpt_timeseries.py: Like dpt_2d.py, but integrates over latitude as well as
                   depth, and plots the resulting 1D tiemseries.
		   To run: Edit the i and j coordinates of the Drake Passage,
		           near the top of the file, for your grid. Then open
			   python or ipython and type "run dpt_timeseries.py".
			   The script will prompt you for paths to the ROMS
			   grid file and the ocean history or averages file.

massloss.py: Calculates and plots timeseries of basal mass loss and
             area-averaged melt rates from major ice shelves during a ROMS
             simulation. Also writes the timeseries to a log file so they don't
	     have to be recomputed if the run is extended; at the beginning of
	     this script, previous values will be read from the same log file
	     if it exists.
	     To run: Open python or ipython, and type "run massloss.py". The
	             script will prompt you for the paths to the ROMS grid file,
		     the ocean history or averages file, and the log file. If
		     you are using ice shelf draft data from something other
		     than RTopo 1.05 you might need to tweak the lat and lon
		     limits.


***CMIP5 ANALYSIS***

cmip5_paths.py: Builds an array of Model objects, one for each of the 39 CMIP5
                models used in Kaitlin's project. Model objects contain
		information about the model, and most usefully a class function
		get_directory which returns the directory containing monthly
		output for the specified variable and experiment.
		To run: The function build_model_list is designed to be called
		        by other functions; see for example
			cmip5_eraint_rms_errors.py. Note that for the class
			function get_directory to work, you must be running on
			raijin and be part of the ua6 project.

eraint_field.py: Reads ERA-Interim monthly data for the given variable name,
                 between the given start and end years. Returns the monthly
		 climatology.
                 To run: The function eraint_field is designed to be called
		         by other functions; see for example
			 eraint_climatology_netcdf.py. If you are using it,
			 be sure to edit the parameters near the top of the
			 file (eg paths to ERA-Interim monthly data).

ecco2_field.py: Reads ECCO2 data for the given variable name, between the given
                start and end years. Interpolates to the northern boundary of
		the circumpolar ROMS domain (currently 30S). Returns the monthly
		climatology.
		To run: The function ecco2_field is designed to be called by
		        other functions; see for example
			ecco2_climatology_netcdf.py. If you are using it, be
			sure to edit the parameters near the top of the file
			(eg paths to ECCO2 data, and the location of the ROMS
			northern boundary).

cmip5_field.py: Reads CMIP5 output for the given model, experiment, and variable
                name. Returns the monthly climatology as well as the grid
		(longitude, latitude, and depth arrays).
		To run: The function cmip5_field is designed to be called by
		        other functions; see for example
			cmip5_atmos_climatology_netcdf.py. Note that for this
			function to work, you must be running on raijin and be
			part of the ua6 project.

eraint_climatology_netcdf.py: Calculates the ERA-Interim monthly climatology
                              from 1992-2005 inclusive, for 11 atmospheric
			      variables (all the variables which ROMS and/or
			      FESOM depend on). Save to a NetCDF file.
			      To run: First edit the variable output_file, near
			              the top of the file, to suit your
				      filesystem. Then open python or ipython
				      and type
				      "run eraint_climatology_netcdf.py".

ecco2_climatology_netcdf.py: Like eraint_climatology_netcdf.py, but for ECCO2
                             ocean variables rather than ERA-Interim atmoshperic
			     variables, interpolated to the northern boundary
			     of the ROMS domain (set in ecco2_field.py).
			     To run: First edit the variable output_file, near
			             the top of the file, to suit your
				     filesystem. Then open python or ipython and
				     type "run ecco2_climatology_netcdf.py".

cmip5_atmos_climatology_netcdf.py: For the given CMIP5 model, calculates the
                        monthly climatology from 1992-2005 inclusive for 11
			atmospheric variables. Interpolates to the ERA-Interim
			grid and saves to a NetCDF file. Note that to run this
			script, you must have previously run
			eraint_climatology_netcdf.py.
			To run: First edit the variables output_file and
			        eraint_file, near the top of the file, to suit
				your filesystem. Then make sure that you have
				scipy version 0.14 or higher (on raijin, this
				means switching to python/2.7.6; instructions
				at the top of the file). To call this function
				for all CMIP5 models, open python or ipython and
				type "run cmip5_atmos_climatology_netcdf.py".
				To call this function for just one model, e.g.
				ACCESS1-0, open python or ipython and type
				"from cmip5_atmos_climatology_netcdf import *"
				and then
				"cmip5_atmos_climatology_netcdf('ACCESS1-0')".

cmip5_ocean_climatology_netcdf.py: For the given CMIP5 model, calculates the
                       monthly climatology from 1992-2005 inclusive for 4 ocean
		       variables. Interpolates to the ECCO2 grid at the northern
		       boundary of ROMS and saves to a NetCDF file. Note that to
		       run this script, you must have previously run
		       ecco2_climatology_netcdf.py.
		       To run: First edit the variables output_file and
		               ecco2_file, near the top of the file, to suit
			       your filesystem. Then make sure that you have
			       scipy version 0.14 or higher (on raijin, this
			       means switching to python/2.7.6; instructions at
			       the top of the file). To call this function for
			       all CMIP5 models, open python or ipython and type
			       "run cmip5_ocean_climatology_netcdf.py".
			       To call this function for just one model, e.g.
			       ACCESS1-0, open python or ipython and type
			       "from cmip5_ocean_climatology_netcdf import *"
			       and then
			       "cmip5_ocean_climatology_netcdf('ACCESS1-0')".

mmm_atmos_netcdf.py: Calculate the multi-model mean of atmospheric climatology
                     files created using cmip5_atmos_climatology_netcdf.py.
		     To run: First edit the variable "directory" near the top
		             of the file. Then open python or ipython and type
			     "run mmm_atmos_netcdf.py".

mmm_ocean_netcdf.py: Calculate the multi-model mean of ocean climatology files
                     created using cmip5_ocean_climatology_netcdf.py.
		     To run: First edit the variable "directory" near the top of
		             the file. Then open python or ipython and type
			     "run mmm_ocean_netcdf.py".

cmip5_eraint_rms_errors.py: Calculates root-mean-square errors (as in Gleckler
                            et al., 2008) for each of 39 CMIP5 models and the
			    multi-model mean, with respect to 11 ERA-Interim
			    atmospheric variables. The domain is the Southern
			    Ocean (all longitudes, and latitudes from the
			    northern boundary of ROMS to the southernmost ocean
			    point not in an ice shelf cavity) and the monthly
			    climatology averaged over 1992-2005 inclusive.
			    Also calculate the relative errors as in Gleckler
			    et al. and make a "portrait plot" of coloured tiles
			    in a model vs. variable matrix. Save both rms errors
			    and relative errors into text files. Note that to
			    run this script, you must have previously run
			    eraint_climatology_netcdf.py,
			    cmip5_atmos_climatology_netcdf.py, and
			    mmm_atmos_netcdf.py.
			    To run: First edit the variable "directory", near
			            the top of the file, to suit your
				    filesystem, and "roms_grid" to point to the
				    roms grid file. Then open python or ipython
				    and type "run cmip5_eraint_rms_errors.py".

cmip5_ecco2_rms_errors.py: Same as cmip5_eraint_rms_errors.py, but for ECCO2
                           ocean variables rather than ERA-Interim atmospheric
			   variables, at the northern boundary of ROMS
			   (currently 30S). Note that to run this script, you
			   must have previously run
			   ecco2_climatology_netcdf.py,
			   cmip5_ocean_climatology_netcdf.py, and
			   mmm_ocean_netcdf.py.
			   To run: First edit the variable "directory", near
			           the top of the file, to suit your filesystem.
				   Then open python or ipython and type
				   "run cmip5_ecco2_rms_errors.py".


***NICE FIGURES***

zice.py: Saves a contour plot of ice shelf draft, with the land masked in white,
         and the non-ice-shelf-covered ocean masked in grey. This script could
	 be easily modified to make a contour plot of any lat-lon variable.
	 To run: Open python or ipython, and type "run zice.py". The script
	         will prompt you for the paths to the ROMS grid file and the
		 desired output figure. 

circumpolar_plot.py: Generates a circumpolar Antarctic plot of the given
                     variable from ROMS. If the variable is depth-dependent,
		     you can choose to plot the surface level, the bottom
		     level, a specific depth in metres, the vertical average
		     throughout the entire water column, or the vertical
		     average between two specified depths in metres.
		     To run: Open python or ipython and type
		             "run circumpolar_plot.py". The script will
			     prompt you for paths to the ROMS grid file,
			     the ocean history or averages file, the variable
			     name, the timestep to plot, what to do about
			     depth (if the variable is depth-dependent),
			     optional bounds on the colour scale, and whether
			     to save the figure in a file or display it on the
			     screen. When the plot is complete, the script will
			     ask if you want to make another, and if so, what
			     changes you want to make to the parameters (eg
			     variable name). It will repeat as many times as you
			     want. This way you don't have to re-enter all the
			     parameters again if only one or two of them have
			     changed.

circumpolar_cice_plot.py: Generates a circumpolar Antarctic plot of the given
                          variable from CICE.
			  To run: Open python or ipython and type
			          "run circumpolar_plot.py". The interface is
				  similar to that of circumpolar_plot.py, but
				  since sea ice variables are not
				  depth-dependent, there is no need to enter
				  depth information.

h_circumpolar.py: Creates a circumpolar Antarctic plot of bathymetry. Follows
                  the same process as circumpolar_plot.py, but since h is not
		  time-dependent, it requires a special case.
		  To run: Open python or ipython and type
		          "run h_circumpolar.py". The script will prompt you
			  for paths to the ROMS grid file and the filename
			  to save the figure as.

ice2ocn_f2flux.py: Creates a circumpolar Antarctic plot of net CICE-to-ROMS
                   freshwater flux in cm/day. Follows the same process as
		   circumpolar_cice_plot.py, but the derived variable
		   (FW flux - salt flux, converted to cm/day) requires a
		   special case.
		   To run: Open python or ipython and type
		           "run ice2ocn_fwflux.py". The script will prompt
			   you for the path to the CICE history file, the
			   timestep to plot, and the filename to save the
			   figure as.

ini_sst_circumpolar.py: Creates a circumpolar Antarctic plot of initial
                        SST from the ROMS initialisation file. Follows the
			same process as circumpolar_plot.py, but since the
			initialisation file is set up differently to the
			ROMS history/averages files, it requires a special
			case.
			To run: Open python or ipython and type
			        "run ini_sst_circumpolar.py". The script
				will prompt you for paths to the ROMS
				grid file, the ROMS initialisation file,
				and the filename to save the figure as.

ini_sss_circumpolar.py: Like ini_sst_circumpolar.py, but for initial SSS.
                        To run: Open python or ipython and type
			        "run ini_sss_circumpolar.py". The script
				will prompt you for paths to the ROMS
				grid file, the ROMS initialisation file,
				and the filename to save the figure as.

zonal_plot.py: Creates a depth vs latitude plot of the given variable. You can
               choose to plot a single longitude slice, a zonal average over
	       all longitudes, or a zonal average between two specific
	       longitudes.
	       To run: Edit grid parameters near the top of the file, and the
	               value of "dlon" (regular longitude spacing for your
		       grid) in the function average_btw_lons. Then open
		       python or ipython and type "run zonal_plot.py". The
		       script will prompt you for paths to the ROMS grid file
		       and the ocean history or averages file, the name of the
		       variable to plot, the timestep number to plot, the type
		       of plot (single longitude, zonally averaged over all
		       longitudes, or zonally averaged between two specific
		       longitudes), the deepst depth to plot, optional bounds on
		       the colour scale, and whether to save the file (and if
		       so, the filename) or display it on the screen. As with
		       circumpolar_plot.py and circumpolar_cice_plot.py, the
		       interface will repeat as many times as you like, and you
		       only have to specify which parameters have changed since
		       the last plot.

cmip5_plot.py: Compare output from CMIP5 models to ERA-Interim (for atmosphere
               variables) or ECCO2 (for ocean variables) by plotting the given
	       variable, time-averaged over the given season and zonally
	       averaged over the Southern Ocean (for atmosphere variables) or
	       the northern boundary of ROMS (for ocean variables). The plot
	       will have the given variable on the x-axis and latitude (for
	       atmosphere variables) or depth (for ocean variables) on the
	       y-axis. Note that in order to run this script, you must first
	       run eraint_climatology_netcdf.py, ecco2_climatology_netcdf.py,
	       cmip5_atmos_climatology_netcdf.py,
	       cmip5_ocean_climatology_netcdf.py, mmm_atmos_netcdf.py, and
	       mmm_ocean_netcdf.py to generate the necessary NetCDF files.
	       To run: First edit the variable "directory", near the top of the
	               file, to suit your filesystem, and the variable
		       "roms_grid" to point to your ROMS grid file. (Note that
		       your choice of roms_grid will affect the latitude bounds
		       on atmosphere plots but not ocean plots, which read
		       NetCDF files which have already been interpolated to
		       the northern boundary of ROMS). Then open python or
		       ipython and type "run cmip5_plot.py". The script will
		       prompt you for the variable name, season code, models
		       to include ('MMM' is an option for multi-model mean),
		       and whether to save the plot (and if so, what the
		       filename should be) or display it on the screen.
		       As with circumpolar_plot.py, circumpolar_cice_plot.py,
		       and zonal_plot.py, the interface will repeat as many
		       times as you like, and you only have to specify which
		       parameters have changed since the last plot.

cmip5_all_plots.py: Call cmip5_plot.py for all models (including the multi-model
                    mean), all variables (atmosphere and ocean), and all
		    seasons. Note that in order to run this script, you must
		    have previously run eraint_climatology_netcdf.py,
		    ecco2_climatology_netcdf.py,
		    cmip5_atmos_climatology_netcdf.py,
		    cmip5_ocean_climatology_netcdf.py, mmm_atmos_netcdf.py, and
		    mmm_ocean_netcdf.py. Also, the directory "cmip5/" must
		    exist.
		    To run: Open python or ipython and type
		            "run cmip5_all_plots.py".

overturning_plot.py: Calculate the meridional overturning streamfunction at the
                     last timestep of the given ROMS history/averages file and
		     make a contour plot in z-space.
		     To run: Open python or ipython and type
		             "run overturning_plot.py". You will be prompted
			     for the path to the ROMS history/averages file
			     and the filename with which to save the plot.

cmip5_max_uwind.py: Create two plots: (1) the maximum zonal wind speed between
                    30S and 65S, and (2) the latitude of that maximum zonal
		    wind speed, both against longitude. Plot results for
		    ERA-Interim as well as the given CMIP5 models, averaged
		    over the given season, for the 1992-2005 climatology.
		    Note that in order to run this script, you must have
		    previously run eraint_climatology_netcdf.py,
		    cmip5_atmos_climatology_netcdf.py, and mmm_atmos_netcdf.py.
		    To run: First edit the variable "directory", near the top
		            of the file, to suit your filesystem. Then open
			    python or ipython and type "run cmip5_max_uwind.py".
			    The script will prompt you for the models to include
			    ('MMM' is an option for multi-model-mean), the
			    season code, and whether to save the plots (and if
			    so, what the filenames should be) or display them
			    on the screen. As with circumpolar_plot.py,
			    circumpolar_cice_plot.py, zonal_plot.py, and
			    cmip5_plot.py, the interface will repeat as many
			    times as you like, and you only have to specify
			    which parameters have changed since the last plot.

uv_vectorplot.py: Make a circumpolar Antarctic plot of speed overlaid with
                  velocity vectors at the given depth (surface, bottom, or
		  vertically aveaged).
		  To run: Open python or ipython and type
		          "run uv_vectorplot.py". You will be prompted for the
			  path to the ROMS history/averages file; the timestep;
			  whether to plot the surface, bottom, or vertically
			  averaged velocities; and whether to save the figure
			  (and if so, what filename to save it under) or display
			  it on the screen. As with the other interactive
			  plotting scripts, the interface will repeat as many
			  times as you like, and you only have to specify which
			  parameters have changed since the last plot.

massloss_map.py: Make a map of unexplained error in annually averaged simulated
                 basal mass loss from each ice shelf that is over 5,000 km^2 in
		 Rignot et al., 2013.
		 To run: First make sure your logfile from massloss.py is up to
		         date, as this script reads simulated basal mass loss
			 timeseries from this logfile. Then open python or
			 ipython and type "run massloss_map.py". The script will
			 prompt you for paths to the ROMS grid file and the
			 mass loss logfile, and whether to save the figure (and
			 if so, what filename) or display it on the screen.

nsidc_aice_monthly.py: Make a figure comparing sea ice concentration from NSIDC
                       (1995 data) and CICE (latest year of spinup under
		       repeated 1995 forcing), for the given month.
		       To run: First edit the variables nsidc_head,
		               nsidc_head_0, nsidc_head_1, and nsidc_tail (near
			       the top of the file) to suit the paths to NSIDC
			       output on your filesystem. Then open python or
			       ipython and type "run nsidc_aice_monthly.py". The
			       script will prompt you for the CICE output file,
			       the month to plot, and whether to save the figure
			       (and if so, what filename) or display it on the
			       screen. As with the other interactive plotting
			       scripts, the interface will repeat as many times
			       as you like, and you only have to specify which
			       parameters have changed since the last plot.

nsidc_aice_seasonal.py: Like nsidc_aice_monthly.py, but creates a 4x2 plot
                        comparing NSIDC and CICE sea ice concentration averaged
			over each season (DJF, MAM, JJA, SON).
			To run: First edit the variables nsidc_head,
			        nsidc_head_0, nsidc_head_1, and nsidc_tail (near
			        the top of the file) to suit the paths to NSIDC
			        output on your filesystem. Then open python or
			        ipython and type "run nsidc_aice_seasonal.py".
			        The script will prompt you for the CICE output
			        file and whether you want to save the figure
				(and if so, what filename) or display it on the
			        screen. This script does not repeat.

ismr_plot.py: Creates a circumpolar plot of ice shelf melt rates averaged over
              the last year of simulation.
	      To run: Open python or ipython and type "run ismr_plot.py". The
	              script will prompt you for the path to a ROMS output file
		      containing at least one year of 5-day averages, and
		      ask you whether you want to save the figure (and if so,
		      what filename) or display it on screen.

bwtemp_plot.py: Creates a circumpolar plot of bottom water temperature, averaged
                over the last year of simulation.
		To run: Open python or ipython and type "run bwtemp_plot.py".
		        The script will prompt you for the path to a ROMS
			output file containing at least one year of 5-day
			averages, and ask you whether you want to save the
			figure (and if so, what filename) or display it on
			screen.

ismr_seasonal_cycle.py: Make a map of the magnitude of the seasonal cycle (over
                        the last year of simulation) in area-averaged melt rates
                        for each ice shelf that is over 5,000 km^2 in Rignot
			et al., 2013.
			To run: First make sure your logfile from massloss.py is
			        up to date, as this script reads simulated
				basal mass loss timeseries from this log file.
				Then open python or ipython and type
				"run ismr_seasonal_cycle.py". The script will
				prompt you for paths to the ROMS grid file and
				the mass loss logfile, and whether to save the
				figure (and if so, what filename) or display it
				on the screen.

massloss_map.py: Make a map of unexplained error in annually averaged simulated
                 basal mass loss from each ice shelf that is over 5,000 km^2 in
		 Rignot et al., 2013.
		 To run: First make sure your logfile from massloss.py is up to
		         date, as this script reads simulated basal mass loss
			 timeseries from this logfile. Then open python or
			 ipython and type "run massloss_map.py". The script will
			 prompt you for paths to the ROMS grid file and the
			 mass loss logfile, and whether to save the figure (and
			 if so, what filename) or display it on the screen.


***ANIMATIONS***

aice_animation.py: Create an animation of sea ice concentration for the given
                   simulation, and save as an mp4 file.
		   To run: If you are on raijin, first type "module load ffmpeg"
		           to make sure you will be able to write the mp4 file.
			   Then edit the variables "directory", "num_ts", and
			   "start_file" near the top of the file to suit your
			   simulation. Then open python or ipython and type
			   "run aice_animation.py". Note that this isn't an
			   encapsulated function but rather just a script, so
			   be careful with existing variable names.


***UTILITY FUNCTIONS***

calc_z.py: Given ROMS grid variables, calculate the s-coordinates, stretching
           curves, and z-coordinates. Assumes Vtransform=2 and Vstretching=2.
	   To run: This is a function designed to be called from other
	           scripts. See for example romscice_nbc.py.

cartesian_grid_2d.py: Given ROMS grid variables, calculate 2D Cartesian
                      integrands dx and dy.
		      To run: This is a function designed to be called from
		              other scripts. See for example massloss.py

cartesian_grid_3d.py: Given ROMS grid variables, calculate 3D Cartesian
                      integrands dx, dy, and dz, as well as 3D z-coordinates.
		      To run: This is a function designed to be called from
		              other scripts. See for example spinup_plots.py.


***OBSOLETE***

roms_grid_rtopo2.py: Interpolate RTopo-2 data to an existing ROMS grid, and do
                     some smoothing. Then overwrite the bathymetry, ice shelf
		     draft, and masks in the ROMS grid with the new RTopo-2
		     values.
		     To run: Modify the user parameters near the bottom of
		             the file. Then make sure that you have scipy
			     version 0.14 or higher (on raijin, this means
			     switching to python/2.7.6; instructions at the top
			     of the file).Then open python/ipython and type
			     "run roms_grid_rtopo2.py".

update_grid.sh: After making changes to bathymetry, ice shelf draft, and masks
                in the ROMS grid (as in roms_grid_rtopo2.py), all input files
		which depend on water column thickness (initial conditions
		and lateral boundary conditions) must be regenerated. If it
		is a spinup, the lateral boundary condition file will have to
		be altered as in romscice_nbc_rep.py. Then a new spinup will
		have to be submitted to test the changes to the grid. It is
		likely that this process will have to be repeated many times
		and this bash script was created to streamline the process.
		To run: Other users will have to alter just about every line in
		        this script as there are a lot of paths hard-coded,
			plus PBS flags for the raijin queue. Hopefully it will
			still be useful. Then type "qsub update_grid.sh" to
			submit to the queue.

convert_era.job: A self-submitting batch job which converts 1 year of
                 ERA-Interim sub-daily data into a ROMS-CICE forcing file,
		 in chunks of 100 6-hour timesteps at once (otherwise the python
		 memory overflows because this is a LOT of data). Depends on
		 roms_cice_atm_subdaily.py.
		 To run: First edit user parameters in romscice_atm_subdaily.py
		         (see below). Then edit the PBS job settings at the top
			 of this file. Then, to get the batch jobs started for
			 a given year (say 1992), type
			 qsub -v YEAR=1992,COUNT=0 convert_era.job
			 You can also submit multiple years quickly with a bash
			 loop:
			 for i in `seq 1992 2009`;
			 do
			     qsub -v YEAR=$i,COUNT=0 convert_era.job
			 done

romscice_atm_subdaily.py: Convert 100 6-hour timesteps of an ERA-Interim
                          atmospheric forcing file (plus 50 12-hour timesteps
			  of ERA-Interim precipitation) to a ROMS-CICE forcing
			  file.
			  To run: Edit user parameters near the top of the
			          script (mainly just file paths). This script
				  is designed to be called by a self-submitting
				  batch job, e.g. convert_era.job.

romscice_ini_ecco.py: Builds a ROMS initialisation file using ECCO2 data for
                      temperature and salinity; starts with a motionless ocean
		      and zero sea surface height.
		      To run: First edit user parameters (file paths and grid
		              parameters) near the bottom of the file. Then make
			      sure that you have scipy version 0.14 or higher
			      (on raijin, this means switching to python/2.7.6;
			      instructions at the top of the file). Then open
			      python/ipython and type "run romscice_ini.py".

convert_ecco.job: A batch job which converts 1 year of ECCO2 data into
                  northern lateral bounday conditions for ROMS.
		  To run: First edit user parameters in romscice_nbc.py
		          (see below). Then edit the PBS job settings at the top
			  of this file, and the module commands if necessary to
			  make sure you have scipy version 0.14 or higher (on
			  raijin this means switching to python/2.7.6).
			  To submit for a given year (say 1992), type
			  qsub -v YEAR=1992 convert_ecco.job
			  You can also submit multiple years quickly with a bash
			  loop:
			  for i in `seq 1992 2009`;
			  do
			      qsub -v YEAR=$i convert_ecco.job
			  done

romscice_nbc_zeta.py: Interpolate one year of monthly AVISO sea surface height
                      data to the northern boundary of the ROMS grid. Save to
		      the existing lateral boundary condition file, created
		      using romscice_nbc.py.
		      To run: Edit file paths and boundary index near the top
		              of the file. Then make sure that you have scipy
			      version 0.14 or higher (on raijin, this means
			      switching to python/2.7.6; instructions at the
			      top of the file). Then open python or ipython
			      and type "from romscice_nbc_zeta import *" then
			      "romscice_nbc_zeta(year)" where year is eg 1992.
			      You can also easily call it in a loop, e.g.
			      for year in range(1995, 2005+1):
			          romscice_nbc_zeta(year)

fill_clouds.py: The ERA-Interim dataset for 6-hour total cloud cover has some
                missing timesteps. This script interpolates the missing
		timesteps in a given file based on existing timesteps in that
		file, at the same time of day and a similar time of year.
		To run: Open python or ipython, and type "from fill_clouds
		        import *", then "fix_file('filename')" where filename
			is the path to the ERA-Interim file that has missing
			timesteps. You can also easily call it in a loop, e.g.
			for year in range(1992, 2009+1):
			    fix_file('../data/ERA_Interim/AN_'+str(year)+'_unlim.nc')

roms_cice_atm_smooth.py: At the beginning of spinups, when the ocean is
                         initially motionless, ROMS can blow up easily if
			 immediately forced with sub-daily atmospheric forcing
			 due to the strong but transient storms. To counteract
			 this problem, this script smooths the given forcing
			 files using a simple moving average (currently 5 days,
			 but can be easily changed).
			 To run: Edit the user parameters near the bottom of the
			         file (paths to forcing files, variable names,
				 interval to smooth over, etc) then open python
				 or ipython and type "run
				 roms_cice_atm_smooth.py".

repeat_forcing.py: If you are spinning up ROMS-CICE-MCT using one repeating year
                   of daily- or sub-daily atmospheric forcing, the easiest
		   option is to have ROMS and CICE follow regular calendars
		   (1995, 1996, 1997, etc) and make 4 copies of this annually-
		   repeating file which the models will cycle through every
		   4 years. One of these years (depending on the start year)
		   must be a leap year. Once you have made four copies of the
		   one-year (non-leap-year) dataset, and named them with the
		   same naming convention (e.g. AN_yyyy_unlim.nc), this script
		   will 1) set the cycle_length attribute to 4 years in each
		   file; 2) alter the time axis of the latter 3 files so they
		   follow the first in sequence; and 3) interpolate data for
		   Feb 29th on the leap year, as the average of the Feb 28th and
		   March 1st records from the same time of day.
		   To run: Edit the user parameters near the bottom of the file
		           (paths to forcing files, years, variable names, etc)
			   then open python or ipython and type "run
			   repeat_forcing.py".

romscice_ini_iceshelf.py: Given a ROMS initial condition file from ECCO2 data
                          (eg created with romscice_ini.py), overwrite the
			  salinity in ice shelf cavities (which aren't in ECCO2)
			  with salinity from Ben's original initial conditions
			  file (not really sure where this data is from, but
			  it's more realistic than filling the cavities with
			  constant salinity, and certainly more stable).
			  To run: Edit the user parameters (paths to 3 files)
			          near the bottom of the script, then open
				  python or ipython and type "run
				  romscice_ini_iceshelf.py".

max_vel.py: Calculate the maximum |u| and |v| at each timestep of the given
            ocean history (or averages) file, and plot the timeseries.
	    To run: Open python or ipython, and type "run max_vel.py". The
	            script will prompt you for the path to the ocean history
		    file.

avg_zeta.py: Calculate the area-averaged sea surface height at each timestep of
             the given ocean history (or averages) file, and plot the
	     timeseries. This script also contains useful code for calculating
	     area averages.
	     To run: Open python or ipython, and type "run avg_zeta.py". The
	             script will prompt you for paths to the ocean history
		     and ROMS grid files.

unesco.py: Calculates the UNESCO seawater equation of state (1980): given
           temperature, salinity, and pressure (depth/10 is fine), returns
	   density.
	   To run: The function unesco is designed to be called by another
	           script. See make_density_file.py for an example.

make_density_file.py: Given an ocean history or averages file with temperature
                      and salinity data, calculate density fields at each
		      timestep using the 1980 UENSCO seawater equation of
		      state. Save in a new file.
		      To run: Open python or ipython, and type
		              "run make_density_file.py". The script will
			      prompt you for the paths to the ROMS grid file,
			      the ocean history or averages file, and the
			      desired path to the new density file.
               




